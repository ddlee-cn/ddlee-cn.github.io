<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> NVIDIA DLSS 4 | LI, Jiacheng (李 家丞) </title> <meta name="author" content="Jiacheng LI"> <meta name="description" content="An overview of the latest advancements in neural rendering with DLSS 4, featuring multi-frame generation, transformer-based ray reconstruction and super-resolution, and relex frame warp."> <meta name="keywords" content="Jiacheng Li, Sony Research, Sony AI, Sony, USTC"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ddlee-cn.github.io/blog/2025/DLSS4/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> LI, Jiacheng (李 家丞) </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Research </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/computational-photography/">Computational Photography</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/rendering-&amp;-generative-ai/">Rendering &amp; Genenerative AI</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/streaming-&amp;-display/">Streaming &amp; Display</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/intelligent-sensing/">Intelligent Sensing</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">NVIDIA DLSS 4</h1> <p class="post-meta"> Created on April 04, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/all"> <i class="fa-solid fa-hashtag fa-sm"></i> all</a>   <a href="/blog/tag/rendering-generative-ai"> <i class="fa-solid fa-hashtag fa-sm"></i> rendering-generative-ai</a>   <a href="/blog/tag/super-resolution"> <i class="fa-solid fa-hashtag fa-sm"></i> super-resolution</a>   <a href="/blog/tag/denoising"> <i class="fa-solid fa-hashtag fa-sm"></i> denoising</a>   <a href="/blog/tag/super-sampling"> <i class="fa-solid fa-hashtag fa-sm"></i> super-sampling</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="i-introduction"><strong>I. Introduction</strong></h2> <p>The foundational principle of DLSS is to decouple the internal rendering resolution from the final display resolution. It allows the graphics pipeline to render the primary 3D scene at a lower internal resolution, thereby significantly reducing the computational workload on the GPU. Subsequently, sophisticated AI algorithms, executed on specialized hardware units known as Tensor Cores within NVIDIA’s RTX series of GPUs, are employed to intelligently reconstruct a high-quality image at the target display resolution. Over its iterations, DLSS has expanded its capabilities significantly beyond mere super-resolution upscaling.</p> <p>The advent and evolution of DLSS signify a paradigm shift in how rendering efficiency is approached. Rather than solely relying on brute-force computation for every pixel at the native display resolution, AI facilitates an intelligent reconstruction from a reduced workload. This strategic reallocation of rendering budget frees up GPU resources, which can then be utilized to achieve higher frame rates, enable more demanding graphical settings (such as higher levels of ray tracing), or drive higher display resolutions, all within the same performance envelope.</p> <p>Furthermore, the trajectory of DLSS highlights a critical co-evolutionary relationship between AI algorithms, GPU architectures, and game engine integration. The capabilities and performance of each DLSS iteration are not merely a product of more sophisticated AI models but are intrinsically linked to advancements in NVIDIA’s GPU hardware—particularly the evolution of Tensor Core capabilities and the introduction of specialized hardware units like the Optical Flow Accelerator in the Ada Lovelace architecture for DLSS 3.0 Frame Generation, and new features in the Blackwell architecture for DLSS 4.</p> <h2 id="ii-evolution-of-nvidia-dlss"><strong>II. Evolution of NVIDIA DLSS</strong></h2> <p>NVIDIA’s Deep Learning Super Sampling has undergone a significant evolutionary journey since its inception, with each major iteration addressing limitations of its predecessor and introducing new AI-driven capabilities. This progression reflects a continuous refinement of AI models, a deeper integration with the graphics pipeline, and an increasing synergy with NVIDIA’s GPU hardware advancements.</p> <ul> <li> <strong>DLSS 1.x (2019)<sup id="fnref:DLSS1"><a href="#fn:DLSS1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>: The Spatial Pioneer</strong> DLSS 1.0 was primarily a <strong>spatial image upscaler</strong>. It employed convolutional auto-encoder neural networks to achieve its upscaling. A defining characteristic of this initial version was its <strong>per-game training requirement</strong>. NVIDIA had to train a unique AI model for each supported game. This training process involved feeding the neural network vast numbers of aliased low-resolution frames from the specific game, alongside corresponding “ground truth” high-resolution reference images. These reference images were typically generated using computationally intensive methods like extreme super-sampling (e.g., 64 samples per pixel) on NVIDIA’s supercomputer infrastructure.11 Some analyses suggest DLSS 1.0 operated via a two-stage process: an initial image enhancement network that utilized the current frame and motion vectors for tasks like edge enhancement and rudimentary spatial anti-aliasing, followed by a separate upscaling network that operated primarily on the single raw low-resolution frame to produce the final output resolution.</li> </ul> <p><img src="https://i.imgur.com/lRRYH6f.jpeg" alt=""></p> <ul> <li> <strong>DLSS 2.x (2020)<sup id="fnref:DLSS2"><a href="#fn:DLSS2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>: The Temporal Revolution and Generalization</strong> DLSS 2.0 represented a major architectural overhaul and a paradigm shift from its predecessor. It introduced a <strong>generalized AI model</strong> and transitioned to being a <strong>temporal anti-aliasing upsampling (TAAU)</strong> technique. This meant it extensively utilized data from previously rendered frames, in addition to the current frame, to inform the reconstruction process. The AI model was a single, generalized convolutional autoencoder network. Crucially, this network was trained on a diverse dataset of non-game-specific content (e.g., thousands of high-resolution images rendered offline with high sample counts), allowing it to work effectively across a wide variety of games and visual styles without the need for per-game retraining. DLSS 2.0 employed <strong>temporal feedback</strong>, where the AI network takes the low-resolution current frame and the high-resolution output from the previous frame (reprojected using motion vectors) to determine, on a pixel-by-pixel basis, how to generate a higher quality current frame.</li> </ul> <p><img src="https://i.imgur.com/XsXiRuD.jpeg" alt=""></p> <ul> <li> <strong>DLSS 3.0 (2022)<sup id="fnref:DLSS3"><a href="#fn:DLSS3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>: Optical Multi Frame Generation (AI Frame Generation)</strong> DLSS 3.0 builds upon the Super Resolution capabilities of DLSS 2.x and introduces a novel AI-powered <strong>Frame Generation</strong> technique. This technology synthesizes entirely new frames, inserting them between traditionally rendered (and super-resolved) frames, rather than just upscaling pixels within existing frames.12 This approach can lead to dramatic increases in displayed FPS, particularly beneficial in CPU-bound scenarios where traditional rendering is limited by the game engine’s processing speed. The <strong>frame generation</strong> component of DLSS 3.0 employs a convolutional autoencoder. This neural network takes current and prior game frames, an optical flow field, and game engine data (such as motion vectors and depth) as inputs to predict and generate the intermediate frame. <strong>Optical Flow Accelerator (OFA)</strong> is another crucial hardware innovation introduced with the NVIDIA Ada Lovelace architecture (found in GeForce RTX 40 Series GPUs). The OFA is a dedicated unit designed to analyze two sequential in-game frames and calculate a dense optical flow field. This field captures pixel-level motion for elements that traditional game engine motion vectors might not accurately model, such as particles, reflections, shadows, and lighting effects.12 The OFA was a hardware-exclusive feature making DLSS 3.0 Frame Generation initially available only on RTX 40 Series GPUs.</li> </ul> <p><img src="https://i.imgur.com/Fw1IDUo.jpeg" alt=""></p> <ul> <li> <strong>DLSS 3.5 (2023)<sup id="fnref:DLSS35"><a href="#fn:DLSS35" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>: Ray Reconstruction (RR)</strong> DLSS 3.5 introduced <strong>Ray Reconstruction</strong>, an AI-powered neural rendering technique specifically designed to improve the image quality of ray-traced effects. It achieves this by replacing the multiple, often hand-tuned, denoisers traditionally used in ray tracing pipelines with a single, more advanced and unified AI network. The Ray Reconstruction AI model was trained on significantly more data—reportedly 5x more than the models used in DLSS 3.0. This extensive training enables the AI to recognize various ray-traced effects (such as global illumination, ambient occlusion, reflections, and shadows) with greater accuracy. It makes more intelligent decisions about how to utilize temporal and spatial data from the noisy ray-traced input, and is better at retaining high-frequency information, which is crucial for subsequent upscaling stages.</li> </ul> <p>The evolution from DLSS 1.0 to 3.5 showcases a clear pattern of iterative problem-solving and increasing specialization. Each version targeted specific limitations of its predecessor—DLSS 1.0’s spatial-only upscaling and per-game training were addressed by DLSS 2.0’s temporal accumulation and generalized model. DLSS 2.0’s residual temporal artifacts and the desire for higher raw FPS paved the way for DLSS 3.0’s Frame Generation, which, in turn, introduced new considerations around latency and UI handling. DLSS 3.5 then focused on a very specific and challenging aspect of modern graphics: the quality of ray tracing denoising. This progression has resulted in a suite of specialized AI models (Super Resolution, Frame Generation, Ray Reconstruction) rather than a single, monolithic AI attempting to solve all rendering challenges. This modularity appears to be a key strategy in tackling the immense complexity of real-time graphics.</p> <p>Concurrently, each major DLSS iteration has become more deeply intertwined with specific NVIDIA GPU hardware capabilities, moving beyond general compute. While Tensor Cores have been foundational to all DLSS versions, DLSS 3.0’s Frame Generation was made practical and performant on the RTX 40 Series due to the dedicated Optical Flow Accelerator. This hardware unit provided crucial optical flow data at high speed, a task that might have been too slow or of lower quality if attempted purely in software on previous-generation hardware. This trend indicates that NVIDIA is not just developing AI algorithms in isolation but is co-designing them with hardware accelerators to achieve performance targets that would otherwise be unattainable. This creates a powerful hardware-software ecosystem but also tends to tie the most advanced features to the latest hardware generations.</p> <p>As DLSS has evolved to boost GPU rendering throughput (via Super Resolution) and apparent frame rates (via Frame Generation), other system bottlenecks, such as CPU performance, memory bandwidth, and input latency, have become more prominent. NVIDIA’s introduction of Reflex as an integral part of DLSS 3.0, and its continued emphasis in the DLSS 4 framework, demonstrates an awareness that true perceived performance is a holistic characteristic of the entire system. Super Resolution eases the load on the GPU’s shading units. Frame Generation can even provide benefits in CPU-bound scenarios by synthesizing frames largely independently of the main game simulation loop.14 However, merely increasing FPS numbers is insufficient if system latency increases to a detrimental degree or if critical elements like the UI become visually compromised. The mandatory inclusion of Reflex with DLSS 3.0 Frame Generation was a direct acknowledgment that the latency introduced by frame interpolation required active mitigation. This holistic view, considering the entire end-to-end pipeline from player input to final display, is crucial for delivering a genuinely enhanced user experience.</p> <h2 id="iii-deep-dive-nvidia-dlss-4"><strong>III. Deep Dive: NVIDIA DLSS 4</strong></h2> <svg viewbox="0 0 980 900" xmlns="http://www.w3.org/2000/svg"> <defs> <lineargradient id="cpuGradient" x1="0%" y1="0%" x2="100%" y2="100%"> <stop offset="0%" style="stop-color:#4A90E2;stop-opacity:1"></stop> <stop offset="100%" style="stop-color:#357ABD;stop-opacity:1"></stop> </lineargradient> <lineargradient id="gpuGradient" x1="0%" y1="0%" x2="100%" y2="100%"> <stop offset="0%" style="stop-color:#76B900;stop-opacity:1"></stop> <stop offset="100%" style="stop-color:#5A8A00;stop-opacity:1"></stop> </lineargradient> <lineargradient id="dlssGradient" x1="0%" y1="0%" x2="100%" y2="100%"> <stop offset="0%" style="stop-color:#FF6B35;stop-opacity:1"></stop> <stop offset="100%" style="stop-color:#E55A2B;stop-opacity:1"></stop> </lineargradient> <lineargradient id="displayGradient" x1="0%" y1="0%" x2="100%" y2="100%"> <stop offset="0%" style="stop-color:#9B59B6;stop-opacity:1"></stop> <stop offset="100%" style="stop-color:#8E44AD;stop-opacity:1"></stop> </lineargradient> <lineargradient id="inputGradient" x1="0%" y1="0%" x2="100%" y2="100%"> <stop offset="0%" style="stop-color:#A0A0A0;stop-opacity:1"></stop> <stop offset="100%" style="stop-color:#808080;stop-opacity:1"></stop> </lineargradient> <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%"> <fedropshadow dx="2" dy="3" stddeviation="3"></fedropshadow> </filter> <marker id="arrowhead" markerwidth="9" markerheight="6" refx="8" refy="3" orient="auto"> <polygon points="0 0, 9 3, 0 6" class="arrowhead-main-fill"></polygon> </marker> <marker id="inputArrowhead" markerwidth="9" markerheight="6" refx="8" refy="3" orient="auto"> <polygon points="0 0, 9 3, 0 6" class="arrowhead-input-fill"></polygon> </marker> <style>.svg-background{fill:transparent}.main-title-text{fill:#4d4d4d}.annotation-text{fill:#737373}.legend-text{fill:#4d4d4d}.legend-background{fill:transparent;stroke:transparent}.flow-arrow-general-stroke{stroke:#737373}.arrowhead-main-fill{fill:#737373}.flow-arrow-input-stroke{stroke:#6482b9}.arrowhead-input-fill{fill:#6482b9}#shadow feDropShadow{flood-color:#000;flood-opacity:.2}</style> </defs> <rect width="980" height="900" class="svg-background"></rect> <text x="490" y="40" text-anchor="middle" font-family="Arial, sans-serif" font-size="22" font-weight="bold" class="main-title-text"> Graphics Pipeline with DLSS 4 Integration </text> <g id="pipeline-row1"> <g id="application-stage"> <rect x="90" y="80" width="240" height="85" rx="8" fill="url(#cpuGradient)" filter="url(#shadow)"></rect> <text x="210" y="108" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Application Stage</text> <text x="210" y="128" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(CPU)</text> <text x="210" y="148" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Game Logic, Physics, Input</text> </g> <g id="geometry-processing"> <rect x="370" y="80" width="240" height="85" rx="8" fill="url(#gpuGradient)" filter="url(#shadow)"></rect> <text x="490" y="108" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Geometry Processing</text> <text x="490" y="128" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(GPU)</text> <text x="490" y="148" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Vertex Shading, Projection</text> </g> <g id="rasterization"> <rect x="650" y="80" width="240" height="85" rx="8" fill="url(#gpuGradient)" filter="url(#shadow)"></rect> <text x="770" y="108" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Rasterization</text> <text x="770" y="128" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(GPU)</text> <text x="770" y="148" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Primitives to Fragments</text> </g> </g> <g id="pipeline-row2"> <g id="pixel-shading-rt"> <rect x="50" y="205" width="240" height="85" rx="8" fill="url(#gpuGradient)" filter="url(#shadow)"></rect> <text x="170" y="233" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Pixel/RT Shading</text> <text x="170" y="253" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(GPU Render Stage)</text> <text x="170" y="273" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Lower res if DLSS active</text> </g> <g id="dlss-ray-reconstruction"> <rect x="330" y="205" width="280" height="85" rx="8" fill="url(#dlssGradient)" filter="url(#shadow)"></rect> <text x="470" y="233" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">DLSS Ray Reconstruction</text> <text x="470" y="253" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(AI Denoiser)</text> <text x="470" y="273" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Cleans noisy ray tracing output</text> </g> <g id="dlss-super-resolution"> <rect x="650" y="205" width="280" height="85" rx="8" fill="url(#dlssGradient)" filter="url(#shadow)"></rect> <text x="790" y="233" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">DLSS Super Resolution</text> <text x="790" y="253" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(AI Upscaler)</text> <text x="790" y="273" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Upscales frames with motion vectors</text> </g> </g> <g id="annotations-row2" font-family="Arial, sans-serif" font-size="11"> <text x="170" y="300" class="annotation-text"> <tspan x="170" text-anchor="middle" dy="0em" font-weight="bold">Pixel/RT Shading Note:</tspan> <tspan x="170" text-anchor="middle" dy="1.3em">Lower internal resolution when</tspan> <tspan x="170" text-anchor="middle" dy="1.3em">DLSS SR/RR features are active.</tspan> </text> <text x="790" y="300" class="annotation-text"> <tspan x="790" text-anchor="middle" dy="0em" font-weight="bold">DLSS Super Resolution:</tspan> <tspan x="790" text-anchor="middle" dy="1.3em">AI upscales frames using temporal</tspan> <tspan x="790" text-anchor="middle" dy="1.3em">data and motion vectors.</tspan> </text> </g> <g id="pipeline-row3"> <g id="post-processing"> <rect x="70" y="370" width="240" height="85" rx="8" fill="url(#gpuGradient)" filter="url(#shadow)"></rect> <text x="190" y="398" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Post-Processing</text> <text x="190" y="418" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(GPU)</text> <text x="190" y="438" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Full-screen effects, Tone Mapping</text> </g> <g id="frame-buffer"> <rect x="350" y="370" width="240" height="85" rx="8" fill="url(#gpuGradient)" filter="url(#shadow)"></rect> <text x="470" y="398" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Frame Buffer</text> <text x="470" y="418" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(GPU Memory)</text> <text x="470" y="438" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Stores final/intermediate frames</text> </g> <g id="dlss-frame-generation"> <rect x="630" y="370" width="280" height="85" rx="8" fill="url(#dlssGradient)" filter="url(#shadow)"></rect> <text x="770" y="398" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">DLSS Frame Generation</text> <text x="770" y="418" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(AI Frame Interpolation)</text> <text x="770" y="438" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Generates additional frames</text> </g> </g> <g id="annotations-row3" font-family="Arial, sans-serif" font-size="11"> <text x="770" y="465" class="annotation-text"> <tspan x="770" text-anchor="middle" dy="0em" font-weight="bold">DLSS Frame Generation:</tspan> <tspan x="770" text-anchor="middle" dy="1.3em">AI generates new frames between</tspan> <tspan x="770" text-anchor="middle" dy="1.3em">rendered frames for higher FPS.</tspan> </text> </g> <g id="pipeline-row4"> <g id="player-input"> <rect x="80" y="535" width="220" height="85" rx="8" fill="url(#inputGradient)" filter="url(#shadow)"></rect> <text x="190" y="563" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Latest Player Input</text> <text x="190" y="583" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(Mouse, Keyboard, etc.)</text> </g> <g id="dlss-reflex-frame-warp"> <rect x="340" y="535" width="280" height="85" rx="8" fill="url(#dlssGradient)" filter="url(#shadow)"></rect> <text x="480" y="563" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">DLSS Reflex Frame Warp</text> <text x="480" y="583" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">(Low Latency Sync)</text> <text x="480" y="603" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="white">Last-moment reprojection</text> </g> <g id="display-output"> <rect x="660" y="535" width="240" height="85" rx="8" fill="url(#displayGradient)" filter="url(#shadow)"></rect> <text x="780" y="563" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">Display</text> <text x="780" y="587" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="white">Final Image Output</text> </g> </g> <g id="annotations-row4" font-family="Arial, sans-serif" font-size="11"> <text x="480" y="630" class="annotation-text"> <tspan x="480" text-anchor="middle" dy="0em" font-weight="bold">DLSS Reflex Frame Warp:</tspan> <tspan x="480" text-anchor="middle" dy="1.3em">Syncs rendering with latest input,</tspan> <tspan x="480" text-anchor="middle" dy="1.3em">reprojects to reduce latency.</tspan> </text> </g> <g id="flow-arrows" stroke-width="2.5" fill="none" class="flow-arrow-general-stroke"> <line x1="330" y1="122.5" x2="360" y2="122.5" marker-end="url(#arrowhead)"></line> <line x1="610" y1="122.5" x2="640" y2="122.5" marker-end="url(#arrowhead)"></line> <path d="M 770 165 V 185 H 170 V 205" marker-end="url(#arrowhead)"></path> <line x1="290" y1="247.5" x2="320" y2="247.5" marker-end="url(#arrowhead)"></line> <line x1="610" y1="247.5" x2="640" y2="247.5" marker-end="url(#arrowhead)"></line> <path d="M 790 290 V 350 H 190 V 370" marker-end="url(#arrowhead)"></path> <line x1="310" y1="412.5" x2="340" y2="412.5" marker-end="url(#arrowhead)"></line> <line x1="590" y1="412.5" x2="620" y2="412.5" marker-end="url(#arrowhead)"></line> <path d="M 770 455 V 515 H 480 V 535" marker-end="url(#arrowhead)"></path> <line x1="300" y1="577.5" x2="330" y2="577.5" class="flow-arrow-input-stroke" stroke-dasharray="5,5" marker-end="url(#inputArrowhead)"></line> <line x1="620" y1="577.5" x2="650" y2="577.5" marker-end="url(#arrowhead)"></line> </g> <g id="legend"> <rect x="50" y="720" width="880" height="130" rx="10" class="legend-background" stroke-width="1.5"></rect> <text x="80" y="745" font-family="Arial, sans-serif" font-size="15" font-weight="bold" class="legend-text">Legend</text> <rect x="100" y="765" width="22" height="18" fill="url(#cpuGradient)" rx="3"></rect> <text x="132" y="779" font-family="Arial, sans-serif" font-size="12" class="legend-text">CPU Processing Stage</text> <rect x="100" y="790" width="22" height="18" fill="url(#gpuGradient)" rx="3"></rect> <text x="132" y="804" font-family="Arial, sans-serif" font-size="12" class="legend-text">Standard GPU Processing Stage</text> <rect x="400" y="765" width="22" height="18" fill="url(#dlssGradient)" rx="3"></rect> <text x="432" y="779" font-family="Arial, sans-serif" font-size="12" class="legend-text">DLSS Technology Component (GPU)</text> <rect x="400" y="790" width="22" height="18" fill="url(#displayGradient)" rx="3"></rect> <text x="432" y="804" font-family="Arial, sans-serif" font-size="12" class="legend-text">Display Output Stage</text> <rect x="700" y="765" width="22" height="18" fill="url(#inputGradient)" rx="3"></rect> <text x="732" y="779" font-family="Arial, sans-serif" font-size="12" class="legend-text">User Input Source</text> <line x1="100" y1="825" x2="122" y2="825" class="flow-arrow-general-stroke" stroke-width="2.5" marker-end="url(#arrowhead)"></line> <text x="132" y="829" font-family="Arial, sans-serif" font-size="12" class="legend-text">Main Data Flow</text> <line x1="400" y1="825" x2="422" y2="825" class="flow-arrow-input-stroke" stroke-width="2.5" stroke-dasharray="4,4" marker-end="url(#inputArrowhead)"></line> <text x="432" y="829" font-family="Arial, sans-serif" font-size="12" class="legend-text">Player Input Data Flow</text> </g> </svg> <p>NVIDIA DLSS 4<sup id="fnref:DLSS4"><a href="#fn:DLSS4" class="footnote" rel="footnote" role="doc-noteref">5</a></sup> represents the latest iteration in the company’s suite of AI-driven rendering technologies, introducing significant architectural advancements and new features aimed at further enhancing image quality, frame rates, and responsiveness in real-time graphics applications. This version builds upon the foundations laid by its predecessors, particularly DLSS 3.x, while incorporating novel AI models and deeper hardware integration with the NVIDIA Blackwell GPU architecture.</p> <p>A hallmark of DLSS 4 is the strategic shift in its AI model architecture for key components and the introduction of more sophisticated frame generation capabilities.</p> <ul> <li> <strong>Transformer-based AI Models for Super Resolution (SR) and Ray Reconstruction (RR):</strong> DLSS 4 marks a pivotal transition from predominantly Convolutional Neural Network (CNN) based architectures, used in previous DLSS versions for Super Resolution and Ray Reconstruction, to <strong>transformer-based models</strong>. Transformers, which have demonstrated remarkable success in fields like natural language processing and offline image generation, employ <strong>attention mechanisms</strong>. These mechanisms allow the model to dynamically weigh the importance of different parts of the input data, enabling them to capture global dependencies and long-range relationships within an image or across frames more effectively than traditional CNNs, which are inherently more focused on local features. This architectural change is anticipated to lead to improved image stability, more effective reduction of ghosting artifacts, better preservation of detail in motion, and smoother edges. The new transformer model for SR is reported to involve four times the number of compute operations compared to its predecessor but has been co-designed with the enhanced Tensor Cores of the Blackwell architecture to maintain high efficiency. The adoption of transformers also suggests a path towards models that can scale more effectively with larger and more diverse training datasets, potentially leading to continuous improvements in generalization and fidelity.</li> </ul> <p><img src="https://i.imgur.com/LzTiQFF.jpeg" alt=""></p> <ul> <li> <strong>Multi Frame Generation (MFG)</strong>: DLSS 4 evolves the Frame Generation capabilities of DLSS 3.0 with a new technique termed Multi Frame Generation (MFG). While DLSS 3.0 generated one additional AI frame for every rendered frame, DLSS 4’s MFG aims to generate up to three additional frames for every one traditionally rendered frame. When combined with DLSS Super Resolution (which itself might be reconstructing a significant portion of the rendered frame’s pixels from a lower internal resolution), MFG has the potential to achieve up to an 8x increase in rendering efficiency compared to brute-force native resolution rendering. The neural architecture for MFG has been redesigned for efficiency and improved quality. It splits the neural component of DLSS 3.0’s Frame Generation into two parts: a larger, more computationally intensive part that runs once per pair of input (rendered) frames, with its output being reusable for the generation of multiple intermediate frames; and a much smaller, lighter part that runs once for every generated output frame. This split architecture is a key optimization that allows for reduced latency and improved efficiency, making the generation of multiple frames feasible within tight real-time budgets.</li> <li> <strong>AI-based Optical Flow:</strong> A significant architectural change in DLSS 4’s Frame Generation pipeline is the replacement of the hardware-based Optical Flow Accelerator (OFA)—a feature of the Ada Lovelace architecture used by DLSS 3.0—with a <strong>highly efficient AI model dedicated to calculating optical flow</strong>. This new AI-driven approach to optical flow is reported to be 40% faster and use 30% less VRAM for the frame generation model compared to the previous OFA-dependent model. Furthermore, it is designed to offer improved image quality, particularly in challenging scenarios like the rendering of particle effects, due to more refined flow estimation capabilities. This AI optical flow model only needs to execute once per rendered frame to support the generation of multiple intermediate frames. This shift from a fixed-function hardware unit to a continuously improvable AI model for optical flow represents a notable trend in AI graphics.</li> </ul> <p><img src="https://i.imgur.com/tHoGMAp.jpeg" alt=""></p> <p>These architectural innovations—the adoption of transformers, the introduction of multi-stage frame generation, and the use of AI for optical flow—collectively aim to deliver higher frame rates and superior image quality by leveraging more sophisticated AI paradigms and co-designing these algorithms with new GPU hardware capabilities.</p> <p><strong>Reflex Integration and Frame Warp</strong> Minimizing latency remains a critical concern, especially when employing frame generation techniques. NVIDIA Reflex, which optimizes the rendering pipeline to reduce system latency, continues to be an integral part of the DLSS framework. DLSS 4 introduces a new enhancement to this system: Reflex Frame Warp.</p> <p>Reflex Frame Warp is described as a late-stage reprojection technique. Its core function is to update the most recently rendered frame based on the very latest player input (e.g., mouse movement, camera adjustments) <em>immediately before</em> that frame is sent to the display. The process involves the CPU calculating the new camera position based on the latest input, and then Frame Warp samples this new position and “warps” the frame just rendered by the GPU to align with this updated perspective. This ensures that the image viewed by the player reflects their most recent actions as closely as possible, aiming to counteract the inherent latency that can be introduced by multi-stage rendering and frame generation pipelines.</p> <p>A key challenge with such warping techniques is handling <strong>disocclusions</strong>—areas of the scene that become newly visible due to the shift in camera perspective and for which no pixel data exists in the original rendered frame. Reflex Frame Warp addresses this through a combination of strategies: minimizing their occurrence by rendering a guard band around the screen border and using layered rendering, and employing <strong>predictive rendering</strong>. In predictive rendering, camera movement is extrapolated from user input, and the frame is initially rendered at this predicted future position. This predicted frame is then warped to the true, most current viewpoint before display, correcting any deviations and significantly reducing the average size of disocclusions with minimal performance impact.3 For any remaining holes created by the reprojection, Frame Warp utilizes a latency-optimized <strong>AI inpainting</strong> approach. This inpainting algorithm incorporates historical frame data, G-buffer information from the predictive rendering pass, and information about the upcoming camera position to reconstruct the missing areas, striving for visual consistency while dynamically adjusting algorithm fidelity to maximize latency savings.</p> <p>Reflex Frame Warp is thus positioned as a critical technology for maintaining a responsive gaming experience, especially when used in conjunction with Multi Frame Generation. It aims to make the significantly increased frame rates delivered by MFG feel immediate and connected to player input.</p> <p><strong>Pipeline Interface: Inputs, Processing, and Outputs</strong> The effective operation of DLSS 4 relies on a sophisticated interplay of data inputs from the game engine and graphics pipeline, specific processing injection points, and carefully constructed outputs.</p> <ul> <li> <strong>Inputs:</strong> <ul> <li> <strong>Super Resolution (Transformer-based):</strong> Likely requires similar inputs to previous DLSS SR versions: low-resolution current frames, motion vectors, depth information, exposure data, and a history buffer containing previous high-resolution outputs for temporal feedback. The transformer model is noted to be better at handling scenarios like animated textures, where it can intelligently decide to ignore motion vectors if they are deemed unreliable for that content.</li> <li> <strong>Ray Reconstruction (Transformer-based):</strong> Takes the noisy, un-denoised output from ray tracing passes as a primary input. It also likely utilizes other G-buffer data (normals, roughness, etc.) and temporal information (motion vectors, history frames) to provide context for the AI to accurately denoise and reconstruct ray-traced effects like global illumination, reflections, and shadows.</li> <li> <strong>Multi Frame Generation (AI Optical Flow):</strong> Requires two sequential rendered (and typically super-resolved) frames as a basis. Instead of OFA output, it uses an internally generated optical flow field from its AI optical flow model. It also utilizes game engine motion vectors and depth data, similar to DLSS 3.0 Frame Generation. The split architecture allows for the output of the first, larger network part (run once per input pair) to be reused for generating multiple intermediate frames.</li> <li> <strong>Reflex Frame Warp:</strong> Operates on the final rendered frame from the GPU. It also takes the latest mouse/controller input from the system, the new camera position calculated by the CPU based on this input, and leverages historical frame data and G-buffers from its predictive rendering stage for inpainting.</li> </ul> </li> <li> <strong>Processing Injection Points:</strong> <ul> <li> <strong>Super Resolution and Ray Reconstruction:</strong> These processes likely occur after the main geometry processing and initial lighting/shading passes (which produce the low-resolution frame and noisy ray-traced data) but before final screen-space post-processing effects (like tone mapping or film grain) and UI rendering. The DLSS 4 research mentions that ray-traced shading (reflections, GI, shadows) is processed at a reduced resolution and then passed through a super resolution model.</li> <li> <strong>Multi Frame Generation:</strong> This is fundamentally a post-processing step. It takes fully rendered (and super-resolved) frames as input and generates additional frames that are then inserted into the display sequence.</li> <li> <strong>Reflex Frame Warp:</strong> This is designed to be a very late-stage process, occurring “just before the rendered frame is sent to the display”. This timing is critical for it to incorporate the absolute latest user input.</li> </ul> </li> <li> <strong>Outputs:</strong> <ul> <li>The Super Resolution and Ray Reconstruction components output high-resolution, high-quality, and temporally stable frames with enhanced ray-traced effects.</li> <li>The Multi Frame Generation component outputs multiple AI-synthesized intermediate frames.</li> <li>The final frames presented to the display are those that have potentially been modified by Reflex Frame Warp to reflect the latest player input.</li> </ul> </li> </ul> <p>Understanding this data flow and the specific points at which DLSS 4 integrates its various processing stages is crucial for game developers seeking to implement the technology effectively and for engineers analyzing its performance characteristics and potential sources of visual artifacts. The shift to an AI-based optical flow model for MFG simplifies one aspect of the input pipeline by removing the dependency on a specific hardware OFA signal, potentially offering more flexibility.</p> <p>The replacement of a specialized hardware unit (the Optical Flow Accelerator in DLSS 3.0) with an AI-based model for optical flow calculation in DLSS 4’s Multi Frame Generation is another noteworthy trend. This indicates that AI models, when executed on sufficiently powerful and generalized AI hardware like modern Tensor Cores, are becoming capable and efficient enough to supplant fixed-function or more specialized hardware blocks for certain complex tasks. While the OFA in the Ada Lovelace architecture was a dedicated silicon block optimized for its specific purpose, its functionality was inherently fixed by its hardware design. In contrast, an AI model for optical flow, as described for DLSS 4, offers the potential for continuous improvement through new training data, architectural refinements, and algorithmic advancements, without necessitating new hardware revisions for that specific function. This approach offers greater flexibility and adaptability. It also potentially frees up die space or power that would have been consumed by a dedicated OFA, which could then be allocated to other GPU resources. This is a strong indicator of AI’s expanding capability to take over tasks that were traditionally the domain of hardware acceleration or complex, hand-tuned algorithms.</p> <p><strong>References</strong></p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:DLSS1"> <p><a href="https://developer.nvidia.com/blog/dlss-what-does-it-mean-for-game-developers/" rel="external nofollow noopener" target="_blank">DLSS: What Does It Mean for Game Developers?</a> <a href="#fnref:DLSS1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:DLSS2"> <p><a href="https://www.nvidia.com/en-us/geforce/news/nvidia-dlss-2-0-a-big-leap-in-ai-rendering/" rel="external nofollow noopener" target="_blank">NVIDIA DLSS 2.0: A Big Leap In AI Rendering</a> <a href="#fnref:DLSS2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:DLSS3"> <p><a href="https://www.nvidia.com/en-us/geforce/news/dlss3-ai-powered-neural-graphics-innovations/" rel="external nofollow noopener" target="_blank">NVIDIA DLSS 3: AI-Powered Performance Multiplier Boosts Frame Rates By Up To 4X</a> <a href="#fnref:DLSS3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:DLSS35"> <p><a href="https://www.nvidia.com/en-us/geforce/news/nvidia-dlss-3-5-ray-reconstruction/" rel="external nofollow noopener" target="_blank">NVIDIA DLSS 3.5: Enhancing Ray Tracing With AI</a> <a href="#fnref:DLSS35" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:DLSS4"> <p><a href="https://developer.nvidia.com/blog/dlss-what-does-it-mean-for-game-developers/" rel="external nofollow noopener" target="_blank">NVIDIA DLSS 4 Introduces Multi Frame Generation &amp; Enhancements For All DLSS Technologies</a> <a href="#fnref:DLSS4" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/AMD-FSR/">AMD FidelityFX Super Resolution</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CG-Pipeline/">The Real-Time Rendering Pipeline</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/Google-Camera/">The Evolution of Google Camera</a> </li> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Jiacheng LI. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>