<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Image and Video Compression | LI, Jiacheng (李 家丞) </title> <meta name="author" content="Jiacheng LI"> <meta name="description" content="An note of the fundamentals of image and video compression techniques."> <meta name="keywords" content="Jiacheng Li, Sony Research, Sony AI, Sony, USTC"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ddlee-cn.github.io/blog/2022/Image-Video-Codec/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> LI, Jiacheng (李 家丞) </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Research </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/computational-photography/">Computational Photography</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/rendering-&amp;-generative-ai/">Rendering &amp; Genenerative AI</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/streaming-&amp;-display/">Streaming &amp; Display</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/intelligent-sensing/">Intelligent Sensing</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Image and Video Compression</h1> <p class="post-meta"> Created on July 25, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/all"> <i class="fa-solid fa-hashtag fa-sm"></i> all</a>   <a href="/blog/tag/streaming-display"> <i class="fa-solid fa-hashtag fa-sm"></i> streaming-display</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#i-concepts-terminology-and-principles">I. Concepts, Terminology, and Principles</a> <ul> <li class="toc-entry toc-h3"><a href="#common-concepts-and-terminology">Common Concepts and Terminology</a></li> <li class="toc-entry toc-h3"><a href="#principles-reducing-data-redundancy-and-visual-redundancy">Principles: Reducing Data Redundancy and Visual Redundancy</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#ii-image-compression-jpeg">II. Image Compression (JPEG)</a> <ul> <li class="toc-entry toc-h3"><a href="#standardizing-body-jpeg-joint-photographic-experts-group">Standardizing Body: JPEG (Joint Photographic Experts Group)</a></li> <li class="toc-entry toc-h3"><a href="#jpeg-encoding-pipeline">JPEG encoding pipeline</a></li> <li class="toc-entry toc-h3"><a href="#further-notes">Further Notes</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#iv-video-compression-h26x">IV. Video Compression (H.26x)</a> <ul> <li class="toc-entry toc-h3"><a href="#standardizing-bodies-m-jepg-mpeg-h26x">Standardizing Bodies: M-JEPG, MPEG, H.26x</a></li> <li class="toc-entry toc-h3"><a href="#core-concepts">Core Concepts</a></li> <li class="toc-entry toc-h3"><a href="#prediction-techniques">Prediction Techniques</a></li> <li class="toc-entry toc-h3"><a href="#pipeline">Pipeline</a></li> <li class="toc-entry toc-h3"><a href="#recent-advances">Recent Advances</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#v-final-remarks">V. Final Remarks</a> <ul> <li class="toc-entry toc-h3"><a href="#ai-based-compression">AI-based Compression</a></li> <li class="toc-entry toc-h3"><a href="#proprietary-vs-open-source">Proprietary VS. Open-Source</a></li> <li class="toc-entry toc-h3"><a href="#coding-for-machine-vision">Coding for Machine Vision</a></li> <li class="toc-entry toc-h3"><a href="#coding-of-generative-models">Coding of Generative Models</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="i-concepts-terminology-and-principles"><strong>I. Concepts, Terminology, and Principles</strong></h2> <h3 id="common-concepts-and-terminology">Common Concepts and Terminology</h3> <ul> <li> <strong>Lossless Compression / Lossy Compression / The interdependent triangle</strong> <ul> <li> <strong>Lossless compression</strong> techniques reduce the size of data by identifying and eliminating statistical redundancy without discarding any information from the original source. This means that the original data can be perfectly reconstructed, bit for bit, from the compressed version. Lossless compression is essential in scenarios where data integrity is paramount and no loss of information is tolerable. This includes executable programs, text documents, source code, and certain types of archival data. In image compression, formats like PNG (Portable Network Graphics) and GIF (Graphics Interchange Format) utilize lossless techniques. Lossless compression is also frequently employed as a stage within lossy compression schemes, for example, to compress motion vectors or the quantized transform coefficients after the primary lossy steps have been applied.</li> <li> <strong>Lossy compression</strong> achieves significantly higher compression ratios than lossless methods by permanently discarding some information from the original data. The key principle is to remove data that is considered less important or less perceptible to human senses. For images and video, this often involves transforming the data into a domain (like the frequency domain using DCT) where perceptual importance can be more easily assessed, followed by quantization, where less important information (e.g., high-frequency details or subtle color variations) is represented with less precision or discarded entirely. Chroma subsampling<sup id="fnref:Chroma"><a href="#fn:Chroma" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> is another common lossy technique specific to color video. The original data cannot be perfectly reconstructed from the compressed version; only an approximation is recovered. There is a fundamental trade-off for lossy compression between the degree of compression (file size or bitrate) and the resulting quality (fidelity to the original). Lossy compression is ubiquitous in multimedia applications due to its ability to drastically reduce file sizes. Common examples include JPEG for still images, MP3 and AAC for audio, and nearly all modern video formats such as MPEG-2, H.264/AVC, and H.265/HEVC.</li> <li> <strong>The interdependent triangle</strong> is a critical ballance to be managed by the codec between three factors: space (file size/bitrate), quality (distortion), and time (complexity). This involves the compression efficiency (how much the data size is reduced, often measured by bitrate), the amount of distortion introduced (particularly in lossy schemes, measured by fidelity to the original), and the computational resources (processing power, memory, and time) required for both encoding and decoding. Improving one aspect often comes at a cost to one or both of the others.</li> </ul> </li> </ul> <pre><code class="language-mermaid">graph TD
        subgraph " "
        direction LR
        S["&lt;b&gt;Space&lt;/b&gt;&lt;br/&gt;(File Size / Bitrate)&lt;br/&gt;&lt;i&gt;Compression Efficiency&lt;/i&gt;"]
        Q["&lt;b&gt;Quality&lt;/b&gt;&lt;br/&gt;(Fidelity vs. Distortion)&lt;br/&gt;&lt;i&gt;e.g., for Lossy Schemes&lt;/i&gt;"]
        T["&lt;b&gt;Time&lt;/b&gt;&lt;br/&gt;(Computational Resources)&lt;br/&gt;&lt;i&gt;Processing Power, Memory, Complexity&lt;/i&gt;"]
        end

    S &lt;--&gt;  Q
    Q &lt;--&gt;  T
    T &lt;--&gt;  S
</code></pre> <ul> <li> <strong>Encoder / Decoder</strong> <ul> <li>An <strong>encoder</strong> is a device or, more commonly in modern systems, a software algorithm that transforms information from its original representation into a coded format, which is typically compressed. A <strong>decoder</strong> is a device or software algorithm that performs the inverse operation of an encoder. Its function is to convert the encoded (compressed) data bitstream back into a representation of the original information. The encoder and decoder are not standalone entities but rather two integral halves of a complete system, defined by a specific codec or standard. The bitstream generated by the encoder is meticulously structured with syntax and semantics that a compatible decoder is designed to interpret. The encoder makes numerous decisions during the compression process (e.g., which prediction modes to use, what quantization levels to apply) and signals these choices within the bitstream. The decoder must parse these signals correctly and apply the precise inverse processes to reconstruct the media. This tight coupling necessitates strict adherence to standardized specifications to ensure interoperability across different media and platforms.</li> <li>Common hardware codecs in GPUs or specialized System-on-Chips (SoCs) include: NVIDIA (NVENC/NVDEC)<sup id="fnref:NVIDIA"><a href="#fn:NVIDIA" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>, Apple (A-series and M-series chips)<sup id="fnref:Apple"><a href="#fn:Apple" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>. Common software codecs are: x264<sup id="fnref:x264"><a href="#fn:x264" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>/x265<sup id="fnref:x265"><a href="#fn:x265" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>, libavcodec(Ffmpeg)<sup id="fnref:ffmpeg"><a href="#fn:ffmpeg" class="footnote" rel="footnote" role="doc-noteref">6</a></sup>, libaom (Alliance for Open Media)<sup id="fnref:libaom"><a href="#fn:libaom" class="footnote" rel="footnote" role="doc-noteref">7</a></sup>.</li> </ul> </li> <li> <strong>Container Format / Codec</strong> <ul> <li>A <strong>container format</strong>, also known as a wrapper format or media container, is a file format whose specification describes how different data elements and metadata coexist in a computer file. In the context of digital media, its primary purpose is to bundle various data streams together into a single file. A <strong>codec (Coder-Decoder)</strong> is an algorithm or software/hardware implementation responsible for the actual compression (encoding) and decompression (decoding) of the audio and video data streams (e.g., H.264 is a video codec, AAC is an audio codec). The container format, on the other hand, does not dictate the compression method itself; rather, it defines how the already compressed data (produced by one or more codecs) and any associated information are organized, stored, and interleaved within a single file.</li> <li> <strong>Multiplexing (muxing)</strong> is the process of combining separate elementary streams into a single, cohesive bitstream suitable for storage or transmission, without changing the codec itself. In contrast, video <strong>transcoding</strong> is a broader scope of converting a video file from one digital format to another. This is a comprehensive operation that can involve changing one or more parameters of the video, including: the video codec and parameters (e.g., resolution), the audio codec and parameters (e.g., sample rate), and the container format.</li> </ul> </li> </ul> <h3 id="principles-reducing-data-redundancy-and-visual-redundancy">Principles: Reducing Data Redundancy and Visual Redundancy</h3> <ol> <li> <strong>Exploiting and Eliminating Redundancy:</strong> Digital images and videos inherently contain a lot of repetitive or predictable information. The compression mindset seeks to identify and remove this redundancy in a way that either allows for perfect reconstruction (lossless) or minimizes noticeable loss (lossy). <ul> <li> <strong>Spatial Redundancy (Within a single image or video frame):</strong> Images often have areas with similar or identical pixel values, like a large patch of blue sky or a plain wall. Instead of storing each pixel’s data individually, compression techniques find more compact ways to represent these uniform regions.</li> <li> <strong>Temporal Redundancy (Between consecutive video frames):</strong> In a video, much of the scene often remains the same from one frame to the next, or objects move in predictable ways. Video compression heavily relies on this by encoding only the <em>differences</em> between frames or by describing how blocks of pixels have moved (motion estimation and compensation).</li> <li> <strong>Statistical Redundancy (Coding Redundancy):</strong> Some pixel values or symbols appear more frequently than others in image or video data. Entropy encoding methods, like Huffman coding or Arithmetic coding, assign shorter binary codes to more common symbols and longer codes to rarer ones, reducing the overall bit count without losing information.</li> </ul> </li> <li> <strong>Leveraging the Limits of Human Perception</strong> This is the cornerstone of <em>lossy</em> compression, which achieves much higher compression ratios by permanently discarding some information.The mindset here is to be selective about what data is thrown away, focusing on information that the human visual system is less sensitive to or is unlikely to perceive. <ul> <li> <strong>Psycho-visual Redundancy:</strong> <ul> <li> <strong>Sensitivity to Brightness over Color:</strong> The human eye is more sensitive to changes in brightness (luma) than to changes in color (chroma). Compression techniques exploit this through <em>chroma subsampling</em><sup id="fnref:Chroma:1"><a href="#fn:Chroma" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, where color information is stored at a lower resolution than brightness information, leading to significant data savings with often imperceptible impact on visual quality.</li> <li> <strong>Sensitivity to Spatial Frequencies:</strong> We are generally less able to perceive very fine details or rapid changes (high spatial frequencies) compared to larger, smoother areas (low spatial frequencies). Transforms like the Discrete Cosine Transform (DCT), used in JPEG, convert image blocks into frequency components. This “energy compaction” concentrates most of the visually important information into a few low-frequency coefficients. The less critical high-frequency coefficients can then be <em>quantized</em> more aggressively—represented with less precision or even discarded entirely—further reducing data size.</li> </ul> </li> </ul> </li> </ol> <h2 id="ii-image-compression-jpeg"><strong>II. Image Compression (JPEG)</strong></h2> <h3 id="standardizing-body-jpeg-joint-photographic-experts-group">Standardizing Body: JPEG (Joint Photographic Experts Group)</h3> <p>JPEG refers to both the committee, the Joint Photographic Experts Group, and the widely implemented image compression standard they developed. The foundational standard is formally designated as ISO/IEC 10918-1<sup id="fnref:JPEGISO"><a href="#fn:JPEGISO" class="footnote" rel="footnote" role="doc-noteref">8</a></sup>.</p> <h3 id="jpeg-encoding-pipeline">JPEG encoding pipeline</h3> <p>Recommendation: <a href="http://www.youtube.com/watch?v=Kv1Hiv3ox8I" rel="external nofollow noopener" target="_blank">Explainer video by Branch Education</a></p> <pre><code class="language-mermaid">graph TD
    A[Image] --&gt; B(Color Space Transformation &lt;br&gt; e.g., RGB to Y'CbCr);
    B --&gt; C(Chroma Subsampling &lt;br&gt; e.g., 4:2:0, 4:2:2 - Lossy);
    C --&gt; D(Image Division &lt;br&gt; into 8x8 Pixel Blocks &lt;br&gt; for Y', Cb, Cr components);
    D --&gt; E(Discrete Cosine Transform  &lt;br&gt; Applied to each 8x8 block &lt;br&gt; Converts spatial to frequency domain);
    E --&gt; F(Quantization &lt;br&gt; Divide DCT coefficients by Q-Table values &lt;br&gt; Round to nearest integer);

    F --&gt; G[Entropy Encoding - Lossless];

    subgraph G [Entropy Encoding]
        direction LR
        G1(Zigzag Scan &lt;br&gt; Reorders quantized AC coefficients) --&gt; G2;
        G2(Run-Length Encoding  &lt;br&gt; Encodes runs of zeros for AC coefficients) --&gt; G4;
        G3(Differential Pulse Code Modulation  &lt;br&gt; Encodes difference of current DC from previous DC) --&gt; G4;
        G4(Huffman Coding / Arithmetic Coding &lt;br&gt; Assigns variable-length codes &lt;br&gt; to DPCM-coded DC &amp; RLE-coded AC symbols);
    end

    G --&gt; H[Bits];

    classDef lossyStep fill:#ffdddd,stroke:#333,stroke-width:2px;
    class C,F lossyStep;
</code></pre> <ol> <li> <strong>Color Space Transformation (e.g., RGB to Y’CbCr):</strong> <ul> <li> <strong>Purpose:</strong> Digital images are often captured or represented in the RGB (Red, Green, Blue) color space. For compression, JPEG often converts the image data into a color space like Y’CbCr<sup id="fnref:YCbCr"><a href="#fn:YCbCr" class="footnote" rel="footnote" role="doc-noteref">9</a></sup>. The human eye is more sensitive to changes in brightness (luma) than to changes in color (chroma).[4, 8, 6, 9, 10] This separation allows the chroma components to be compressed more aggressively in subsequent steps.</li> <li> <strong>Process:</strong> <ul> <li> <strong>Y’ (Luma):</strong> Represents the brightness or luminance component (the black and white information) of the image.</li> <li> <strong>Cb and Cr (Chroma):</strong> Represent the blue-difference and red-difference color components, respectively.</li> </ul> </li> </ul> </li> <li> <strong>Chroma Subsampling (Downsampling):</strong> <ul> <li> <strong>Purpose:</strong> To reduce the amount of color data based on the human visual system’s lower acuity for color detail. This is a lossy step. This step significantly reduces the amount of data for the color channels with minimal perceived impact on image quality for most images.</li> <li> <strong>Process:</strong> The Cb and Cr (chroma) components are sampled at a lower spatial resolution than the Y’ (luma) component. Common schemes include: <ul> <li> <strong>4:4:4:</strong> No subsampling. Luma and chroma have the same resolution.</li> <li> <strong>4:2:2:</strong> Chroma is sampled at half the horizontal resolution of luma.</li> <li> <strong>4:2:0:</strong> Chroma is sampled at half the horizontal and half the vertical resolution of luma. This is very common.</li> </ul> </li> </ul> </li> </ol> <p><img src="https://i.imgur.com/AU8EzR2.png" alt=""></p> <ol> <li> <strong>Image Division into 8x8 Pixel Blocks:</strong> <ul> <li> <strong>Purpose:</strong> To prepare the image data for the Discrete Cosine Transform (DCT).</li> <li> <strong>Process:</strong> Each component of the image (Y’, Cb, and Cr, after any subsampling) is divided into non-overlapping 8x8 blocks of pixels. If the dimensions of a component are not a multiple of 8, padding might be applied.</li> </ul> </li> <li> <strong>Discrete Cosine Transform (DCT):</strong> <ul> <li> <strong>Purpose:</strong> To convert the spatial information of each 8x8 pixel block into frequency domain information. The DCT has excellent “energy compaction” properties, meaning it concentrates most of the visually significant information into a few coefficients. By transforming to the frequency domain, it becomes easier to separate perceptually important information (low frequencies) from less important information (high frequencies). The DCT itself is not lossy, except for potential rounding errors in computation.</li> <li> <strong>Process:</strong> A 2D DCT (typically Type-II DCT) is applied to each 8x8 block. This transforms the 64 pixel values into 64 DCT coefficients. <ul> <li>The top-left coefficient is the <strong>DC coefficient</strong>, representing the average value of the 64 pixels in the block.</li> <li>The other 63 coefficients are <strong>AC coefficients</strong>, representing successively higher spatial frequencies (details and textures).</li> </ul> </li> </ul> </li> <li> <strong>Quantization:</strong> <ul> <li> <strong>Purpose:</strong> This is the primary lossy step in JPEG compression. It reduces the precision of the DCT coefficients, especially the high-frequency ones that are less perceptible to the human eye.</li> <li> <strong>Process:</strong> Each of the 64 DCT coefficients in a block is divided by a corresponding value from an 8x8 <strong>Quantization Matrix</strong> (also called a Q-table), and the result is rounded to the nearest integer. <ul> <li>JPEG typically uses two Q-tables: one for the luma component and one for the chroma components (which are usually more aggressively quantized).</li> <li>The values in the Q-table are larger for higher-frequency AC coefficients, leading to more aggressive compression (many become zero) for those details. The “quality” setting in JPEG encoders often scales these Q-table values.</li> </ul> </li> </ul> </li> <li> <strong>Entropy Encoding:</strong> This is a lossless stage that further compresses the quantized DCT coefficients. It typically involves several sub-steps: <ul> <li> <strong>Zigzag Scan:</strong> <ul> <li> <strong>Purpose:</strong> To group low-frequency coefficients (which are more likely to be non-zero after quantization) together and create long runs of zeros for high-frequency coefficients.</li> <li> <strong>Process:</strong> The 63 AC coefficients in each 8x8 quantized block are read out in a zigzag pattern, from the top-left (low frequency) to the bottom-right (high frequency).</li> </ul> </li> <li> <strong>Run-Length Encoding (RLE) for AC Coefficients:</strong> <ul> <li> <strong>Purpose:</strong> To efficiently encode the many zero-valued AC coefficients that result from quantization, especially after the zigzag scan.</li> <li> <strong>Process:</strong> Instead of coding each zero, RLE typically encodes a pair: <code class="language-plaintext highlighter-rouge">(run_length_of_preceding_zeros, next_non_zero_AC_coefficient_value)</code>. A special End-of-Block (EOB) code (often (0,0)) indicates that all remaining AC coefficients in the block are zero.</li> </ul> </li> <li> <strong>Differential Pulse Code Modulation (DPCM) for DC Coefficients:</strong> <ul> <li> <strong>Purpose:</strong> To exploit the correlation between the DC coefficients of adjacent 8x8 blocks (average block intensities often change gradually).</li> <li> <strong>Process:</strong> Instead of encoding the absolute value of each DC coefficient, the difference between the current block’s DC coefficient and the DC coefficient of the <em>previous</em> block is encoded.</li> </ul> </li> <li> <strong>Huffman Coding (or Arithmetic Coding):</strong> <ul> <li> <strong>Purpose:</strong> To assign shorter binary codes to more frequently occurring symbols (DPCM-coded DC values and RLE-coded AC pairs) and longer codes to less frequent ones.</li> <li> <strong>Process (Huffman):</strong> <ul> <li>For DC coefficients, the <em>category</em> (size in bits) of the DPCM difference is Huffman coded, followed by the actual bits of the difference.</li> <li>For AC coefficients, the combined <code class="language-plaintext highlighter-rouge">(run_length, category_of_next_non_zero_AC_coefficient)</code> symbol is Huffman coded, followed by the actual bits of the non-zero AC coefficient.</li> </ul> </li> <li> <strong>Arithmetic Coding:</strong> An alternative, often slightly more efficient entropy coding method also specified in the JPEG standard, but less commonly used due to historical patent issues and wider Huffman support.</li> </ul> </li> </ul> </li> </ol> <p>The result of these steps is a compressed bitstream representing the image, which is then typically wrapped in a file format like JPEG. The decompression process essentially reverses these steps, using the stored Q-tables and Huffman tables to reconstruct an approximation of the original image.</p> <h3 id="further-notes">Further Notes</h3> <ul> <li> <strong>The basis function.</strong> For image compression, ideal basis functions should possess several properties: they should allow the energy (or information content) of typical image signals to be “compacted” into a relatively small number of transform coefficients; they should be computationally efficient to calculate; and they should ideally have good decorrelation properties, meaning they transform correlated pixel data into less correlated coefficients.</li> <li> <strong>The trade-off.</strong> The Quantization Matrix serves as the direct control mechanism for the lossiness and, consequently, the compression-versus-quality trade-off in JPEG. The specific values chosen for the 64 entries in this matrix (often scaled by a single “quality” factor in user interfaces) dictate precisely how much information is discarded from each corresponding frequency component of the DCT. By employing larger divisor values for high-frequency DCT coefficients (to which the human visual system is less sensitive) and smaller divisor values for the DC and low-frequency AC coefficients (which are more critical for perceived quality), JPEG tailors the information loss profile to align with human visual perception.</li> <li> <strong>The scanning order.</strong> The zigzag scanning pattern applied to the quantized AC coefficients before RLE is not an arbitrary choice. It systematically orders the coefficients from the lowest spatial frequencies (excluding the DC coefficient, which is handled separately) to the highest. This ordering is synergistic with the effects of DCT and quantization: since high-frequency coefficients are more likely to be quantized to zero, the zigzag scan tends to create longer contiguous runs of zeros. This, in turn, maximizes the effectiveness of Run-Length Encoding<sup id="fnref:Huffman"><a href="#fn:Huffman" class="footnote" rel="footnote" role="doc-noteref">10</a></sup>, as RLE achieves greater compression when it encounters longer sequences of identical symbols.</li> </ul> <h2 id="iv-video-compression-h26x"><strong>IV. Video Compression (H.26x)</strong></h2> <h3 id="standardizing-bodies-m-jepg-mpeg-h26x">Standardizing Bodies: M-JEPG, MPEG, H.26x</h3> <ul> <li> <strong>Motion-JPEG (M-JPEG)</strong> is a straightforward video compression format where each individual frame of the video sequence is compressed independently using the JPEG still image compression standard.34 Essentially, an M-JPEG stream is a sequence of complete JPEG images.</li> <li> <strong>MPEG (Moving Picture Experts Group)</strong> is a working group operating under the joint auspices of ISO (International Organization for Standardization) and IEC (International Electrotechnical Commission), specifically as part of ISO/IEC JTC 1/SC 29 (Coding of audio, picture, multimedia and hypermedia information). MPEG has produced a highly influential family of standards that have become foundational to digital television, optical disc media (DVD, Blu-ray), internet streaming, and many other digital video applications. Key video coding standards include MPEG-1 (used for Video CD), MPEG-2 (used for DVD and digital broadcast), MPEG-4 Part 2 (Visual), MPEG-4 Part 10 (Advanced Video Coding, also H.264), and MPEG-H Part 2 (High Efficiency Video Coding, also H.265).</li> <li> <strong>H.262 / MPEG-2 Part 2 Video</strong> is a standard developed and maintained collaboratively by the ITU-T (International Telecommunication Union - Telecommunication Standardization Sector) as Recommendation H.262, and by ISO/IEC MPEG as Part 2 of the MPEG-2 standard (formally ISO/IEC 13818-2).</li> <li> <strong>H.264 / MPEG-4 Part 10 Advanced Video Coding (AVC)</strong> was a landmark joint development effort by the ITU-T Video Coding Experts Group (VCEG), where it is known as Recommendation H.264<sup id="fnref:H264"><a href="#fn:H264" class="footnote" rel="footnote" role="doc-noteref">11</a></sup>, and by ISO/IEC MPEG, where it is designated as MPEG-4 Part 10, Advanced Video Coding (formally ISO/IEC 14496-10). The collaborative body responsible for its development was known as the Joint Video Team (JVT). H.264/AVC rapidly became the most widely adopted video codec due to its superior compression performance. It is used in Blu-ray Discs, numerous streaming services (e.g., YouTube, Netflix), digital television broadcasting (especially for HD content), video conferencing systems, mobile devices, and digital security cameras.</li> <li> <strong>H.265 / High Efficiency Video Coding (HEVC)</strong> was also jointly developed by ITU-T VCEG (as Recommendation H.265<sup id="fnref:H265"><a href="#fn:H265" class="footnote" rel="footnote" role="doc-noteref">12</a></sup>) and ISO/IEC MPEG (as MPEG-H Part 2, High Efficiency Video Coding, formally ISO/IEC 23008-2).45 The collaborative body for HEVC was the Joint Collaborative Team on Video Coding (JCT-VC).</li> </ul> <h3 id="core-concepts">Core Concepts</h3> <p><img src="https://i.imgur.com/YYeEB3R.jpeg" alt=""></p> <ul> <li> <strong>Group of Pictures (GoP)</strong> is a sequence of consecutively coded frames in a video stream, typically starting with an I-frame and followed by a specific arrangement of P-frames and B-frames. The GoP structure defines the dependencies between frames and dictates how often I-frames (random access points) occur. A common GoP structure might be represented as I B B P B B P B B P B B I…. The pattern (e.g., IBBP) repeats between I-frames. Key parameters describing a GoP are its length (N, the distance between successive I-frames) and the distance between anchor frames (I or P frames, denoted M, which also implies the number of B-frames between them).</li> <li> <strong>I-frame (Intra-coded picture)</strong> is coded entirely using intra-frame prediction techniques, meaning it makes no reference to any other frames in the video sequence. It is essentially a self-contained, independently decodable picture, compressed similarly to a still image (e.g., using DCT, quantization, and entropy coding on its own pixel data). The frequency of I-frames (i.e., the GoP length N) directly impacts <strong>random access</strong> capability. In case of transmission errors that might corrupt data in P-frames or B-frames, an I-frame acts as a “refresh” point. Errors cannot propagate past an I-frame because its decoding is independent. I-frames are the least compressed type of frame because they do not exploit temporal redundancy, resulting in the largest size among the frame types.</li> <li> <strong>P-frame (Predictive-coded picture)</strong> is coded using inter-frame prediction from one or more <em>preceding</em> (in display or decoding order) reference frames, which are typically an earlier I-frame or another P-frame. P-frames encode motion vectors (indicating where the predicted blocks come from in the reference frame) and the quantized residual (the difference between the actual block and its prediction).</li> <li> <strong>B-frame (Bi-predictive-coded picture)</strong> is coded using inter-frame prediction that can reference one or more <em>preceding</em> frames and/or one or more <em>future</em> (in display order, but already decoded and stored) reference frames. This means a B-frame can find predictor blocks by looking “backwards” in time, “forwards” in time, or by interpolating between blocks from both past and future reference frames. B-frames typically offer the highest compression efficiency among the three frame types. The ability to use future frames as references often allows for better matches (e.g., for uncovered regions) or more accurate motion interpolation. However, the use of B-frames introduces greater encoding and decoding delay because the decoder needs to have future reference frames available before it can decode a B-frame that depends on them. This also means the decoding order of frames can differ from their display order.</li> <li> <strong>Macroblock / Coding Tree Unit (CTU)</strong> refer to the fundamental rectangular blocks into which a video frame is partitioned for the purpose of compression processing. Most key coding operations, including motion estimation, motion compensation, spatial prediction, transform coding, and quantization, are performed on these units or sub-units derived from them. <strong>H.264/AVC</strong> primarily uses a <strong>Macroblock</strong> as its basic processing unit. A macroblock in H.264 typically covers a 16x16 luma sample region, along with the corresponding chroma samples (e.g., two 8x8 chroma blocks in 4:2:0 subsampling). These 16x16 macroblocks can be further partitioned into smaller blocks (e.g., 16x8, 8x16, 8x8, and down to 4x4) for motion compensation, allowing for finer adaptation to motion details. <strong>H.265/HEVC</strong> introduces the concept of a <strong>Coding Tree Unit (CTU)</strong>, which replaces the macroblock as the fundamental processing unit. CTUs can be significantly larger than H.264 macroblocks, with configurable sizes such as 64x64, 32x32, or 16x16 luma samples (with 64x64 being common for UHD video). Each CTU is then recursively partitioned using a quadtree structure into smaller <strong>Coding Units (CUs)</strong>. CUs can vary in size (e.g., from 64x64 down to 8x8 in the HEVC main profile). Each CU is then further divided into one or more <strong>Prediction Units (PUs)</strong>, which define the block size and mode for prediction (intra or inter), and one or more <strong>Transform Units (TUs)</strong>, which define the block size for the transform and quantization of the residual signal.</li> <li> <strong>Motion Vector (MV)</strong> is a two-dimensional vector, typically represented as (dx, dy), that specifies the displacement of a block or region in the current frame relative to its corresponding matching block or region in a reference frame. MVs are the direct output of the motion estimation process performed by the encoder. They are then used by the motion compensation process (at both encoder and decoder) to generate the predicted block from the reference frame.</li> <li> <strong>Reference Frame(s) / Picture(s)</strong> are previously decoded frames (which could be I-frames or P-frames, and in some advanced schemes, even B-frames) that are stored in a memory buffer called the Decoded Picture Buffer (DPB) at both the encoder and decoder.44 These stored frames serve as the source from which predictor blocks are formed during the inter-prediction of subsequent P-frames or B-frames. Modern video coding standards like H.264/AVC and H.265/HEVC allow for the use of multiple reference frames for predicting a single block. This means the encoder can choose the best match from a larger set of candidate blocks in different temporal locations, often leading to more accurate predictions and improved compression efficiency, especially in scenes with complex motion patterns, occlusions, or repetitive movements.</li> <li> <strong>Residual (Prediction Error)</strong> is the sample-by-sample difference between the actual pixel values of a block in the current frame and the pixel values of its corresponding motion-compensated predictor block (for inter-prediction) or intra-predicted block (for intra-prediction). Typically, the residual block undergoes a transform (like DCT or a variant), quantization, and entropy coding.</li> </ul> <h3 id="prediction-techniques">Prediction Techniques</h3> <p>Prediction is the heart of video compression, aiming to create a model of the current picture based on already coded information. The difference between the actual picture and the prediction (the residual) is what gets coded.</p> <p><img src="https://i.imgur.com/ZWewD7f.jpeg" alt=""></p> <ul> <li> <strong>Intra-frame Prediction</strong>, or simply “intra-prediction,” exploits spatial redundancy by predicting the pixel values of a current block based on the values of already coded and reconstructed neighboring pixels within the <em>same</em> frame or picture.41 The encoder selects the prediction mode (e.g., a specific direction from which to extrapolate pixel values) that yields the best match, and then encodes the chosen mode and the prediction residual.</li> <li> <strong>Inter-frame Prediction</strong>, or “inter-prediction,” exploits temporal redundancy by predicting a block of pixels in the current frame from similar blocks located in one or more previously coded and reconstructed frames, known as reference frames. This is the fundamental technique used for P-frames and B-frames. This process involves two key components: motion estimation (at the encoder) and motion compensation (at both encoder and decoder). <ul> <li> <strong>Motion Estimation (ME).</strong> The goal of Motion Estimation is to determine the displacement (motion) of objects or regions between the current frame being encoded and one or more reference frames that have already been coded and reconstructed. In block-matching ME, the current frame is divided into blocks (e.g., macroblocks in H.264, or Prediction Units (PUs) derived from CUs in HEVC). For each block in the current frame, the encoder searches for a block in a designated search window within a reference frame that provides the “best match”. The “best match” is typically identified by minimizing a cost function, such as the Sum of Absolute Differences (SAD) or Mean Squared Error (MSE) between the pixel values of the current block and the candidate block in the reference frame.</li> <li> <strong>Motion Compensation (MC).</strong> Once a motion vector (MV) has been determined for a block by the ME process, Motion Compensation (MC) or Motion Compensated Prediction (MCP) is the process of actually forming the predicted block. The decoder (and the encoder, for reconstructing its own reference frames to ensure synchronization) uses this MV to identify and retrieve the corresponding predictor block from the specified reference frame. This predictor block is then used as the prediction for the current block. Typically, the decoded residual (prediction error) is added to this predictor block to reconstruct the final pixel values of the current block. A crucial aspect of modern MCP is handling MVs that point to sub-pixel locations (e.g., half-pixel or quarter-pixel positions). Since these fractional positions don’t directly correspond to stored pixel values in the reference frame, interpolation filters are used to generate the required sample values at these sub-pixel coordinates.</li> </ul> </li> </ul> <h3 id="pipeline">Pipeline</h3> <p><img src="https://i.imgur.com/gaQ5Mhb.jpeg" alt=""></p> <p>The above diagram summerizes the HEVC<sup id="fnref:HEVC"><a href="#fn:HEVC" class="footnote" rel="footnote" role="doc-noteref">13</a></sup> pipeline. Key steps are:</p> <ul> <li>Frame Preparation &amp; Coding Tree Unit (CTU) Partitioning</li> <li>Prediction Unit (PU) and Transform Unit (TU) Specification</li> <li>Prediction (Enhanced Intra &amp; Inter)</li> <li>Residual Calculation &amp; Transform</li> <li>Quantization &amp; Scaling</li> <li>Entropy Coding: Context-Adaptive Binary Arithmetic Coding (CABAC)</li> <li>In-Loop Filtering: Deblocking Filter (DBF) and Sample Adaptive Offset (SAO)</li> <li>Bitstream Formation</li> </ul> <h3 id="recent-advances">Recent Advances</h3> <p>The evolution<sup id="fnref:HEVCTutorial"><a href="#fn:HEVCTutorial" class="footnote" rel="footnote" role="doc-noteref">14</a></sup> from H.264/AVC to H.265/HEVC are</p> <ul> <li>Higher Compression Efficiency: About 50% bitrate reduction for similar quality.</li> <li>Larger and More Flexible Coding Units: CTUs and adaptable CU/PU/TU partitioning.</li> <li>More Sophisticated Prediction: More intra modes, advanced motion vector prediction, merge mode.</li> <li>Larger Transform Sizes &amp; Transform Skip.</li> <li>Sample Adaptive Offset (SAO): Additional in-loop filter for improved quality.</li> <li>Enhanced Parallel Processing Tools: Tiles and WPP for efficient multi-core encoding/decoding.</li> </ul> <h2 id="v-final-remarks"><strong>V. Final Remarks</strong></h2> <h3 id="ai-based-compression">AI-based Compression</h3> <p>AI-based compression, often referred to as “learned” or “neural” compression, utilizes deep learning—specifically, neural networks—to replace or enhance parts of the traditional pipeline. Instead of relying on predefined mathematical formulas, these systems are trained on vast datasets of images and videos. They learn the most efficient ways to represent visual information, often achieving significantly higher compression ratios and better perceptual quality.</p> <p>The core of many AI-based image codecs is a type of neural network called an autoencoder. It consists of two main parts:</p> <ul> <li>An encoder network that analyzes an image and compresses it into a compact latent representation (a highly compressed set of data).</li> <li>A decoder network that takes this latent representation and reconstructs the image.</li> </ul> <p>The entire system is trained end-to-end to minimize the difference between the original and reconstructed images, as well as the size of the latent representation. This approach allows the AI to discover more complex and efficient ways to encode visual data than human-engineered algorithms.</p> <p>Although in the academic literature, many papers are published claiming outperforming latest standards, the adoption of AI solutions faces multiple challenges:</p> <ul> <li>Computational Complexity: Unlike traditional codecs that use well-defined mathematical operations (like the DCT), AI models require significant processing power, often relying on specialized hardware like GPUs or NPUs (Neural Processing Units). This creates a high barrier to entry for low-power or older devices, potentially delaying widespread adoption until such hardware is ubiquitous.</li> <li>Interpretability: Traditional algorithms are deterministic and transparent; their steps can be followed and understood. Many advanced AI models are considered “black boxes.”</li> <li>Data Bias and Privacy Issue: A significant ethical hurdle is that any biases present in the training data will be learned and potentially amplified by the AI model. Many large datasets are created by scraping the internet, which often involves using personal photos and copyrighted material without explicit consent. This raises serious privacy concerns and legal issues regarding intellectual property.</li> <li>Difficulty in Standardization: With an AI model, simply standardizing the model’s architecture isn’t enough, as the trained “weights” (the learned parameters) are what define its behavior. Distributing and standardizing these large sets of weights is a new challenge.</li> </ul> <h3 id="proprietary-vs-open-source">Proprietary VS. Open-Source</h3> <p>Through the years, the video compression field is dominated by proprietary standards developed jointly by the ISO/IEC Moving Picture Experts Group (MPEG) and the ITU-T Video Coding Experts Group (VCEG), e.g., HEVC/H.265. Proprietary standards are built upon a collection of patents owned by various companies. To legally use the standard, a device manufacturer or software developer must acquire licenses for this intellectual property, which almost always involves paying royalties. Instead of a single, clear entity to negotiate with, patent holders often group themselves into “patent pools.”<sup id="fnref:Pool"><a href="#fn:Pool" class="footnote" rel="footnote" role="doc-noteref">15</a></sup></p> <p><img src="https://i.imgur.com/cQvZ6ld.jpeg" alt=""> On the other hand, the proprietary model also hinder the application in the scenario of web streaming. The proprietary codecs have struggled to gain native support in major web browsers like Chrome and Firefox. These projects rely on open-source components and cannot easily integrate technology with royalty obligations.</p> <p>Device manufacturers, software developers, and content creators may choose to stick with an older, “good enough” standard (like H.264) whose licensing situation is settled and well-understood, rather than invest in a new one with unpredictable costs. Currently, H.264 remains the most widely compatible codec despite its age.</p> <p>The formation of the Alliance for Open Media (AOMedia) by giants like Google, Amazon, Netflix, and Apple was a direct response to the frustrating licensing landscape of HEVC. Their creation of the royalty-free AV1 codec has permanently fragmented the market. Now, many streaming services must support both HEVC (for the broadcast and Apple ecosystems) and AV1 (for the web and Android ecosystems), which increases complexity and cost.</p> <h3 id="coding-for-machine-vision">Coding for Machine Vision</h3> <p>The core idea of Coding for Machine Vision (CMV), also known as Video Coding for Machines (VCM), is to fundamentally shift the objective of compression. Instead of optimizing for human perceptual quality, the goal is to compress video while preserving the specific information that artificial intelligence algorithms need to perform their tasks accurately and efficiently. The problem is that traditional codecs like H.264 and HEVC are “unaware” of what a machine is looking for. They might discard subtle, high-frequency textures or details that they deem irrelevant to human vision, but which could be critical for an AI to distinguish between two objects.</p> <p>Instead of compressing the pixels of the video, the AI model at the source (e.g., in the camera) first extracts the essential information—the “features”—it needs for its task. The system then compresses and transmits only these features. This method offers the highest possible compression, as all visually redundant pixel data is discarded. The downside is that it’s highly task-specific, and you cannot reconstruct a viewable video from the stream.</p> <h3 id="coding-of-generative-models">Coding of Generative Models</h3> <p>The emergence of generative models like NeRF (Neural Radiance Fields) represents a fundamental shift in how we capture and represent visual reality. Instead of storing a collection of 2D images or a 3D mesh, these models create a “digital twin” of a scene within the weights of a neural network. This allows for the rendering of photorealistic, novel views from any position or angle.</p> <p>In the sense of generative model, the definition of the information changes from visual output to the parametric model that generates the scene. This has given rise to a new and rapidly evolving field of research: the coding and compression of generative models. The core idea is a complete departure from traditional video compression. Instead of compressing the output (the pixels of an image or video), the goal is to compress the generative model itself.</p> <p><strong>References</strong></p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:Chroma"> <p><a href="https://en.wikipedia.org/wiki/Chroma_subsampling" rel="external nofollow noopener" target="_blank">Chroma subsampling - Wikipedia</a> <a href="#fnref:Chroma" class="reversefootnote" role="doc-backlink">↩</a> <a href="#fnref:Chroma:1" class="reversefootnote" role="doc-backlink">↩<sup>2</sup></a></p> </li> <li id="fn:NVIDIA"> <p><a href="https://developer.nvidia.com/video-codec-sdk" rel="external nofollow noopener" target="_blank">NVIDIA Codec SDK</a> <a href="#fnref:NVIDIA" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:Apple"> <p><a href="https://en.wikipedia.org/wiki/Apple_silicon" rel="external nofollow noopener" target="_blank">Apple Silicon</a> <a href="#fnref:Apple" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:x264"> <p><a href="https://www.videolan.org/developers/x264.html" rel="external nofollow noopener" target="_blank">x264 - VideoLan</a> <a href="#fnref:x264" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:x265"> <p><a href="https://www.videolan.org/developers/x264.html" rel="external nofollow noopener" target="_blank">x265 - VideoLan</a> <a href="#fnref:x265" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:ffmpeg"> <p><a href="https://www.ffmpeg.org/libavcodec.html" rel="external nofollow noopener" target="_blank">Libavcodec Documentation</a> <a href="#fnref:ffmpeg" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:libaom"> <p><a href="https://aomedia.googlesource.com/aom/" rel="external nofollow noopener" target="_blank">Alliance for Open Media</a> <a href="#fnref:libaom" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:JPEGISO"> <p><a href="https://www.iso.org/standard/18902.html" rel="external nofollow noopener" target="_blank">ISO/IEC 10918-1:1994</a> <a href="#fnref:JPEGISO" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:YCbCr"> <p><a href="https://en.wikipedia.org/wiki/YCbCr" rel="external nofollow noopener" target="_blank">YCbCr - Wikipedia</a> <a href="#fnref:YCbCr" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:Huffman"> <p><a href="https://en.wikibooks.org/wiki/JPEG_-_Idea_and_Practice/The_Huffman_coding" rel="external nofollow noopener" target="_blank">JPEG - Idea and Practice/The Huffman coding</a> <a href="#fnref:Huffman" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:H264"> <p><a href="https://www.itu.int/rec/T-REC-H.264" rel="external nofollow noopener" target="_blank">H.264 : Advanced video coding for generic audiovisual services</a> <a href="#fnref:H264" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:H265"> <p><a href="https://www.itu.int/rec/T-REC-H.265" rel="external nofollow noopener" target="_blank">H.265 / High Efficiency Video Coding (HEVC)</a> <a href="#fnref:H265" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:HEVC"> <p><a href="https://iphome.hhi.de/wiegand/assets/pdfs/2012_12_IEEE-HEVC-Overview.pdf" rel="external nofollow noopener" target="_blank">Overview of the High Efficiency Video Coding (HEVC) Standard</a>, in T-CSVT, 2012 <a href="#fnref:HEVC" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:HEVCTutorial"> <p><a href="https://eems.mit.edu/wp-content/uploads/2014/06/H.265-HEVC-Tutorial-2014-ISCAS.pdf" rel="external nofollow noopener" target="_blank">Design and Implementa/on of Next Genera/on Video Coding Systems (H.265/HEVC Tutorial)</a>, in ISCAS Tutorial 2014 <a href="#fnref:HEVCTutorial" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:Pool"> <p><a href="https://accessadvance.com/hevc-worldwide-patent-landscape/" rel="external nofollow noopener" target="_blank">HEVC Worldwide Essential Patents Landscape</a> <a href="#fnref:Pool" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/DLSS4/">NVIDIA DLSS 4</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/AMD-FSR/">AMD FidelityFX Super Resolution</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CG-Pipeline/">The Real-Time Rendering Pipeline</a> </li> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Jiacheng LI. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>